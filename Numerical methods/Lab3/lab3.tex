\documentclass [12pt]{article}


\usepackage{ucs}
\usepackage[utf8x]{inputenc} %Поддержка UTF8
\usepackage{cmap} % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[english,russian]{babel} %Пакет для поддержки русского и английского языка
\usepackage{graphicx} %Поддержка графиков
\usepackage{float} %Поддержка float-графиков
\usepackage[left=20mm,right=15mm, top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}
\usepackage{mathtools} 
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\renewcommand{\baselinestretch}{1.2}
 
\usepackage{color} 
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

\usepackage{listings}
 
\lstset{
	language=Python,
	basicstyle=\ttm,
	otherkeywords={self},             % Add keywords here
	keywordstyle=\ttb\color{deepblue},
	emph={MyClass,__init__},          % Custom highlighting
	emphstyle=\ttb\color{deepred},    % Custom highlighting style
	stringstyle=\color{deepgreen},
	frame=tb,                         % Any extra options here
	showstringspaces=false            % 
}
 
\usepackage{hyperref}
 
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={My title},    % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new PDF window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,          % color of internal links (change box color with linkbordercolor)
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\title{}
\date{}
\author{}

\begin{document}
\begin{titlepage}
\thispagestyle{empty}
\begin{center}
Федеральное государственное бюджетное образовательное учреждение высшего профессионального образования \\Московский государственный технический университет имени Н.Э. Баумана

\end{center}
\vfill
\centerline{\large{Лабораторная работа №3}}
\centerline{\large{по курсу <<Численные методы>>}}
\centerline{\large{<<Численное интегрирование>>}}
\vfill
\hfill\parbox{5cm} {
           Выполнил:\\
           студент группы ИУ9-62 \hfill \\
           Иванов Георгий\hfill \medskip\\
           Проверила:\\
           Домрачева А.Б.\hfill
       }
\centerline{Москва, 2017}
\clearpage
\end{titlepage}
\textsc{\textbf{Цель:}} 
\\ Сравнительный анализ методов численного интегрирования:
\begin{enumerate}
\item Метод средних прямоугольников
\item Метод трапеций
\item Метод парабол (метод Симпсона)
\end{enumerate}

\textsc{\textbf{Постановка задачи:}}

\textbf{Дано:}  Интеграл $$\int\limits_a^b f(x)\,dx $$где $f(x)$ - подынтегральная функция, непрерывная на отрезке$[a,b]$.

\textbf{Найти:} значение интеграла $$I^{*} \approx  I $$

\textbf{Тестовый пример:} $$ I = \int\limits_0^1 e^x\,dx = e^x \bigg|_0^1 = e - 1 = 1.718282$$

\textsc{\textbf{Теоретические сведения:}}

Численное интегрирование — вычисление значения определённого интеграла (как правило, приближённое). Суть численного интегрирования состоит в расчёте значения определённого интеграла по взвешенным значениям подынтегральной функции, без использования первообразной функции.

Задача численного интегрирования состоит в замене исходной подинтегральной функции $f(x)$, для которой трудно или невозможно записать первообразную в аналитике, некоторой аппроксимирующей функцией $\phi(x)$. Такой функцией обычно является полином (кусочный полином).$$\phi(x)=\sum\limits_1^n c_{i}\varphi_{i}(x)$$То есть вычисление интеграла сводится к $$I=\int\limits_a^b f(x)\,dx = \int\limits_a^b \phi(x)\,dx + R$$ где $R=\int\limits_a^b r(x)\,dx $ - априорная погрешность метода на интервале интегрирования, а $r(x)$ - априорная погрешность метода на отдельном шаге интегрирования. 

В зависимости от степени и вида аппроксимисирующего полинома имеем различные численные методы интегрирования. Различают метод прямоугольников (левых, правых, средних), метод трапеций, метод парабол (метод Симпсона), метод Гаусса, метод Гаусса-Кронрода, метод Чебышёва, метод Монте-Карло. 

В ходе данной лабораторной работы рассмотрим первые три метода, а именно метод прямоугольников, метод трапеций, метод парабол (Симпсона). Степени кусочных полиномов будут соотвественно равны нулю, единице, двойке.

\textbf{1. Метод средних прямоугольников:}

Метод прямоугольников — метод численного интегрирования функции одной переменной, заключающийся в замене подынтегральной функции на полином нулевой степени - отрезком, параллельным оси абсцисс. Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении площади под графиком суммированием площадей конечного числа прямоугольников, ширина которых будет определяться расстоянием между соответствующими соседними узлами интегрирования, а высота — значением подынтегральной функции в этих узлах.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx \approx f(\frac{x_{j-1}+x_{j}}{2})h$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx h\sum\limits_{i=1}^n f(\frac{x_{j-1}+x_{j}}{2}) = h\sum\limits_{i=1}^n f(a+i*h-\frac{h}{2})$$

\textbf{2. Метод трапеций:}

Метод трапеций — метод численного интегрирования функции одной переменной, заключающийся в замене подынтегральной функции на полином первой степени - отрезком, параллельным оси абсцисс. Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении площади под графиком суммированием площадей конечного числа прямоугольных трапеций, высота которых будет определяться расстоянием между соответствующими соседними узлами интегрирования, а основания — значениями подынтегральной функции в этих узлах.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx \approx \frac{f(x_{j-1})+f(x_{j})}{2}h$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx \frac{h}{2}\sum\limits_{i=0}^n f(x_i) = h(\frac{f(a)+f(b)}{2}+\sum\limits_{i=1}^{n-1} f(x_i)))$$

\textbf{3. Метод Симпсона:}

Метод Симпсона — метод численного интегрирования функции одной переменной, заключающийся в приближении подынтегральной функции $[a;b]$ на интерполяционный полином второй степени, то есть квадратичной параболой $y=a_ix^2+b_ix+c_i$, проходящей через точки $(x_{i-1};f(x_{i-1}))$, $(x_{i-0.5};f(x_{i-0.5}))$, $(x_{i};f(x_{i}))$ Это делается для того, чтобы в качестве приближенного значения определенного интеграла  $\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx $ взять $\int\limits_{x_{j-1}}^{x_{j}} a_jx^2+b_jx+c_j\,dx $, который мы можем вычислить по формуле Ньютона-Лейбница.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Парабола Симпсона представлена формулой:
$$ a_jx^2+b_jx+c_j = f(x_{i-0.5}) + \frac{f(x_{i})-f(x_{i-1})}{h}(x-x_{i-0.5}) + \frac{f(x_{i})-2f(x_{i-0.5})+f(x_{i-1})}{\frac{h^2}{2}}(x-x_{i-0.5})^2 $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x_{j-0.5})\,dx + \frac{f(x_{j})-f(x_{j-1})}{h}\int\limits_{x_{j-1}}^{x_{j}}(x-x_{j-0.5})\,dx + \frac{f(x_{j})-2f(x_{j-0.5})+f(x_{j-1})}{\frac{h^2}{2}}\int\limits_{x_{j-1}}^{x_{j}}(x-x_{j-0.5})^2\,dx =$$ $$ = \frac{h}{6}(f(x_{j-1})+4f(x_{j-0.5})+f(x_{j}))$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx \frac{h}{6}(f(a)+f(b)+4\sum\limits_{i=1}^n f(x_{i-0.5}) + 2\sum\limits_{i=1}^{n-1} f(x_i)))$$

\textbf{Вычисление интервалов различными методами с учётом погрешности:}

$I = \int\limits_a^b f(x)\,dx $

$I = I^{*} + O(h^k)$, где $k$ - порядок точности метода.

$k = 2$ - для методов средних прямоугольников и трапеций.
$k = 4$ - для методов Симпсона.

$O(h^k) \approx ch^k$, где $h$ - шаг, $c$ - некоторая константа. Равенство приблизительное из-за вычислительной погрешности.

Тогда:
$I \approx I^{*}_{h} + ch^k$, где $I^{*}_{h}$ - приближенное значение интеграла, вычисленного с помощью определенного метода с шагом $h$

Считаем, что вычисления проводятся без вычислительной погрешности, можно записать строгое равенство:
$$I = I^{*}_{h} + ch^k$$

Соответственно, при вычислении значения интеграл с шагом метода $\frac{h}{2}$ равенство будет иметь вид:
$$I = I^{*}_{\frac{h}{2}} + c(\frac{h}{2})^k$$

Из двух равенств следует равенство:

$$I^{*}_{h} + ch^k = I^{*}_{\frac{h}{2}} + c(\frac{h}{2})^k$$
$$c(\frac{h}{2})^k = \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$

Тогда получим значение интеграла с погрешностью:

$$I = I^{*}_{\frac{h}{2}} + \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$

где значение R уточнение по Ричардсону:

$$R =  \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$ 

Далее, используем правило Рунге, чтобы построить процедуру приближенного вычисления интеграла с заданной точностью $\varepsilon$ . Будем начинать вычисления с некоторого значения шага $h$, затем последовательно уменьшать это значения в два раза, каждый раз вычисляя приближенное значение $I^{*}_{h}$. Условие остановки приближенного вычисления интеграла с заданной точностью $\varepsilon$ c уточнением по Ричардсону: $$\abs{R}<\varepsilon$$

\textsc{\textbf{Практическая реализация:}}
Листинг 1. Численное интегрирование
\begin{lstlisting}[language=python]

#!python
# -*- coding: utf-8 -*-
import math

def func(x):
    return math.exp(x)

def method_of_rectangles(func,a,b,n):
    h = (b-a)/n
    return h*sum(func(a+i*h+h/2) for i in range(n))

def method_of_trapezoid(func,a,b,n):
    h = (b-a)/n
    series_of_sum = sum(func(a+i*h) for i in range(1,n))
    return h * ((func(a)+func(b))/2 + series_of_sum)

def method_of_simpson(func,a,b,n):
    h = (b-a)/n
    series_of_sum  = sum(func(a+i*h-h/2) for i in range(1,n+1))
    series_of_sum1 = sum(func(a+i*h)     for i in range(1,n))
    return h/6 * (func(a)+func(b) + 4*series_of_sum + 2*series_of_sum1)

def richardson(int_h,int_h2,k):
    return (int_h - int_h2) / (2**k-1)

def calc_integral(epsilon,method,k,func,a,b):
    for eps in epsilon:
        print("Eps = " + str(eps))
        n = 1
        r = float("+inf")
        iteration = 0
        int_h = 0
        while abs(r) >= eps:
            n *= 2
            int_h2 = int_h
            int_h = method(func,a,b,n)

            r = richardson(int_h,int_h2,k)
            iteration += 1

        print(" Iterations = %d" % (iteration))
        print(" Result = " + str(int_h))
        print(" Result with Richardson: " + str(int_h + r))

if __name__ == "__main__":
    eps = [0.1 ** i for i in range(1,4)]
    print("Method of rectangles: ")
    calc_integral(eps,method_of_rectangles,2,func,0,1)
    print("Method of trapezoids: ")
    calc_integral(eps,method_of_trapezoid ,2,func,0,1)
    print("Method of Simpson: ")
    calc_integral(eps,method_of_simpson   ,4,func,0,1)

\end{lstlisting}

\textsc{\textbf{Результаты:}}

Для тестирования полученной программы был выбран интеграл $$ I = \int\limits_0^1 e^x\,dx = e^x \bigg|_0^1 = e - 1 = 1.718282$$

В качестве  $\varepsilon$ для каждого метода были выбраны следующие значения: $$\varepsilon=0.1,\varepsilon=0.01,\varepsilon=0.001$$

Ниже приведена таблица результата полученной программы (Листинг 1) на указанных выше методах:

\begin{center}
\begin{tabular}{ |l|l|l|l| }
  \hline
   Метод & \parbox[t]{2cm} {Кол-во \\ итераций} & \parbox[t]{4cm}{Значение интеграла \\ без уточнения по \\ Ричардсону} & \parbox[t]{4cm}{Значение интеграла \\ c уточнением по \\ Ричардсону} \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.1$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 2 & 1.713815279771087 & 1.7182494674780466 \\ \hline
  Метод трапеций & 2 & 1.7272219045575166 & 1.718318841921747 \\ \hline
  Метод Симпсона & 2 & 1.7182841546998966 & 1.7182818422184398 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.01$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 2 & 1.713815279771087 & 1.7182494674780466 \\ \hline
  Метод трапеций & 2 & 1.7272219045575166 & 1.718318841921747 \\ \hline
  Метод Симпсона & 2 & 1.7182841546998966 & 1.7182818422184398 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.001$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 4 & 1.7180021920526605 & 1.7182817010716516 \\ \hline
  Метод трапеций & 4 & 1.7188411285799945 & 1.718281974051892 \\ \hline
  Метод Симпсона & 2 & 1.7182841546998966 & 1.7182818422184398 \\ \hline
\end{tabular}
\end{center}

\textsc{\textbf{Выводы:}}

В ходе выполнения лабораторной работы были рассмотрены три различных численных метода интегрирования: метод средних прямоугольников, метод трапеций, метод парабол (Симпсона). Была написана реализация данных методов на языке программирования Python.

Сравнивая результаты в таблице вычислений, метод парабол (Симпсона) является наиболее точным по сравнению с другими численными методами (меньшее количество итераций и более точный результат вычислений). 

Кроме этого, анализируя оставшиеся два метода численного интегрирования, метод средних прямоугольников точнее, чем метод трапеций, так как погрешность метода трапеций в два раза выше, чем у метода средних прямоугольников. Однако на практике найти среднее значение на элементарном интервале можно только у функций, заданных аналитически (а не таблично), поэтому использовать метод средних прямоугольников удаётся далеко не всегда в отличие от метода трапеций с произвольным шагом. В силу разных знаков погрешности в формулах трапеций и средних прямоугольников истинное значение интеграла обычно лежит между двумя этими оценками.

\end{document}

